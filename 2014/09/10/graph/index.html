<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Jin › 第十篇-Data Structures and Algorithm Analysis in C-第九章笔记</title>
  <meta name="author" content="Jin Liu">
  
  <meta name="description" content="在看Data Structures and Algorithm Analysis in C: Second Edition 第九章GRAPH ALGORITHM，以下记录自己新的理解
GRAPH ALGORITHM
本章我们主要讨论图理论中几个常见的问题。这些问题不仅因为它们确实很有用，另外，在实际的应用程序中如果不仔细注意选择数据结构，这些应用运行非常慢">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="第十篇-Data Structures and Algorithm Analysis in C-第九章笔记"/>
  <meta property="og:site_name" content="Jin"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Jin" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-32857089-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">Jin</a></h1>
  <h2><a href="/">Newer@Computer</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">关于我</a></li>
      
      <li><a href="/archives">文章归档</a></li>
      
      <li><a href="/links">相关链接</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title">第十篇-Data Structures and Algorithm Analysis in C-第九章笔记</h1>
  

      
      <time datetime="2014-09-10T07:29:53.000Z">9月 10 2014</time>
      
    </header>
    <div class="entry">
      
        <p><em>在看Data Structures and Algorithm Analysis in C: Second Edition 第九章GRAPH ALGORITHM，以下记录自己新的理解</em></p>
<h1 id="GRAPH_ALGORITHM">GRAPH ALGORITHM</h1>
<p>本章我们主要讨论图理论中几个常见的问题。这些问题不仅因为它们确实很有用，另外，在实际的应用程序中如果不仔细注意选择数据结构，这些应用运行非常慢<br><a id="more"></a></p>
<h2 id="我们将：">我们将：</h2>
<ul>
<li>展示一些实际生活中能够转换到图理论上的问题</li>
<li>给出解决几个常见问题的算法</li>
<li>展示正确的数据结构选择是能够直接地减少算法的运行时间的</li>
<li>展示一个重要的技术，深度优先算法，并观察它怎样在线性时间内解决一些看上去非平凡的问题</li>
</ul>
<h2 id="关键点：_"><strong>关键点： </strong></h2>
<ul>
<li>Definitions<ul>
<li>图G = (V, E)包含一个点（vertices）集V，一个边（edge）集E，每一条边是一个点对(v, w)，其中v，w∈V。边有时也叫做弧（arcs），如果组成边的点对是有序的，那么图就是有向图，有向图通常叫做digraph，点w和点v是紧邻的（vertex w is adjacent to v），当且仅当(v, w)∈V。在无向图（undirected graph）中，如果有边(v, w)，那么也有边(w, v)，点w和点v紧邻，并且点v和点w紧邻。有时候，边还有一个属性，叫做边的权重（weight或cost）</li>
<li>图中的路径（path）是一串顶点w1，w2，w3，…，wn，并且对于 1≤ i &lt;n，有(wi, wi+1)∈E，path的长度就是路径中边的个数，等于n-1。我们允许一条路径从某个顶点出发，不经过其它顶点就回到自身，这个路径不包括边，所以路径长度为0，通常用它来处理一些特殊情况</li>
<li>如果图里包含一条边(v, v)，那么路径v,v被叫做一个loop，我们通常考虑的图是没有loop的，一个简单路径（simple path）是指路径中的所有顶点都是不同的，除了第一个和最后一个顶点可以一样</li>
<li>一个cycle是指有向图中长度大于1并且w1=wn的一条路径，当这个cycle对应的路径（path）是简单的（simple path），那么我们说cycle是简单的（simple cycle），对于无向图，cycle另外要求，路径中没有相同的边，因此无向图中路径u，v，u  不是cycle，因为在无向图中(u, v)和(v, u)是同一条边，在有向图中，该路径可以说是一个cycle，因为无向图中(u, v)，(v, u)是两条不同的边。如果图中不存在cycle，那么这个图就叫做非循环的（acyclic），一个非循环的有向图，通常叫做DAG（directed acyclic graph）</li>
<li>如果一个无向图中，每一个节点都有通到所有其他节点的路径，那么我们称这个无向图为连通的（connected），满足上述条件的有向图我们称它是强连通（strong connected）的。如果一个有向图不是强连通的，但是它对应的基础图（忽略边的方向，有向图的点和边组成的无向图）是连通的，那么我们称它为弱连通（weakly connectd）的。如果图中的每一对节点之间都有一条边，那么我们就称这个图是完全图（complete graph）</li>
<li>机场系统是现实情景中可以用图来建模的例子，每一个机场是一个节点，如果代表机场的两个节点间有一个没有中间停靠站的航线，那么这两个节点间就有一条边，边上可能会有权重，可以代表时间，距离，或者飞行成本。，因为从另一点出发可能所花时间更长或者成本更高（例如不同地区的税不同），所以认为这个模型是有向图是有道理的。也可以保证一般的机场系统是强连通的，所以从任何一个机场飞到任何另一个机场都是可能的。因此我们希望快速的找到最好的一条路径，所谓最好路径，是指路径中的边最少，或者根据路径中某一个或者所有边的权重来衡量</li>
<li>交通网也可以用图来建模。每一个十字路口代表一个节点，每条街代表一条边，边的权重可以表示：限制速度，车道数量等指标。我们因此可以找到最短路线或者找到交通瓶颈的位置</li>
<li>本章接下来将会看一些图的更多应用。这些应用对应的图模型都很大，所以图算法的效率至关重要</li>
<li>Representation of Graphs<ul>
<li>我们讨论有向图的表示方法（无向图类似）</li>
<li>一个简单的表示图的方法就是用一个二维数组，通常被叫做邻接矩阵（adjacency matrix），对每一条边(u, v)，我们设置a[u][v]=1，否者数组中该项设置为0，如果图中的边是有权重的，那么我们将a[u][v]设置为边的权重，并且使用一个非常大或者非常小的权重来作为哨兵（sentinel）表示不存在该边（无权重邻接表中的0）。例如，如果我们要找到最便宜的航线，我们可以将不存在的边对应的邻接表中的值设置为∞。如果我们需要找到最昂贵的飞行路线，我们可以使用-∞或者0来表示不存在的边</li>
<li>尽管使用邻接矩阵非常简单，但是空间复杂度是Θ(|V|^2)，只有当图没有太多条边的时候，这个条件可以允许。当图的密度很大（dense）的时候（当|E|=Θ(|V|^2)的时候，这样邻接矩阵中的大部分元素都是有意义的，不是大部分元素的值都是代表没有边的0，或者正负无穷），邻接矩阵表示法是适当的，但是很多情况下，这个条件是不满足的</li>
<li>如果图密度不大，换而言之，图是稀疏的（sparse），一个更好的方案是使用邻接表。对于任何一个节点，我们用一个链表记录所有和它相邻的其它节点，这个表示方法的空间复杂度为O(|E| + |V|)，如果边有权重，那么也可以记录在表示节点的结构中</li>
<li>邻接表是表示图的标准方法，无向图也可以类似的表示，每一条边(u, v)都出现在两个链表中，因此空间需求也是两倍。图算法中一个常见的需求就是找出和某个节点v相邻的所有其它节点，使用这个表示方法，这个需求可以只通过遍历一遍正确的邻接表就可以，在实际应用中，图中的节点是有名字的而不仅是数字，并且在编译阶段它们是未知的。因为名字未知，所以不能定义一个名字数组，因此我们需要将未知的名字映射到数字上，最简单的办法就是用hash表。过程是这样的：在hash表中，当读取图进行初始化时候，对于每一个节点，我们存放它的名字和范围从1到|V|的相应序号，比如当读取一条边时，我们检查边的两个节点是否在hash表中分配了序号，如果已经分配了序号，我们就使用已经分配的序号，否则我们分配这个节点下一个可用的序号，并且将节点名和序号存放在hash表中，使用这个转化，所有图算法都能使用内部序号。因为最终我们要输出节点的真实名字而不是内部序号，所以对于每一个内部序号，我们需要记录它对应的节点名字，一种方法是使用字符串数组，但是如果节点名字太长，这将消耗大量内存，因为每个节点的名字都存了两遍。另一种方法是用一个指向hash表中的记录的指针数组，这稍微破坏了哈希表的抽象数据类型（ADT）</li>
</ul>
</li>
</ul>
</li>
<li>Topological Sort<ul>
<li>拓扑排序是指有向非循环图中节点的顺序，如果有一条从vi到vj的路径，那么vj就排在vi后面</li>
<li>如果图中含有循环cycle，那么拓扑排序是不可能的，因为对于在一个cycle中的两个节点v和w，可以说v排在w的前面，也可以说w排在v前面。此外，图中拓扑排序序列也不是唯一的，任何符合拓扑排序规则的都是正确的</li>
<li>一个简单的寻找拓扑排序序列的算法是：首先找到任意一个入度为0的节点，打印这个节点并且从图中删除它和它关联的边。然后我们对图一直重复这个过程<ul>
<li>这个简单算法，需要一个记录V个节点入度的数组，每次遍历这个数组找到入度为0的节点，并且删除它，减少和这个节点邻接的其它节点的入度，遍历一次入度数组的时间复杂度为O(|V|)，而这个算法需要重复这个过程|V|次，所以时间复杂度为O(|V|^2)</li>
</ul>
</li>
<li>基于上面的算法，另一种考虑是，一般图是稀疏的（sparse），因此当删除一个节点的时候，不是所有其它节点都需要更新入度，然而在上面的算法中，为了找到一个入度为0的节点，我们遍历了整个数组，实际上对这点是可以优化的<ul>
<li>优化方法是，我们使用一个数组（数据结构上可以是队列也可以是堆栈）记录所有入度为0的节点，我们从这个数组中选择入度为0的节点，删除它，并且减少与它相邻节点的入度，如果某些节点的入度也变为0，我们有将这些节点加入到记录入度为0节点的数组中（队列或者是堆栈），这样就消除了上面那个算法中，每次都遍历整个入度数组的低效的缺点</li>
<li>优化后的算法的时间复杂度为O(|E|+|V|)，因为删除节点对入度的修改，最多对每条边执行一次，另外每个节点加入队列或者堆栈和从队列或者堆栈中删除（enqueue &amp; dequeue）最多一次，而且初始化计算入度和建立入度为0的数组的时间复杂度也只是和图的规模有关</li>
</ul>
</li>
</ul>
</li>
<li>Shortest-Path Algorithms<ul>
<li>这一节，将介绍各种最短路径算法。输入是权重图（weighted graph）：每一条边(vi, vj)都有一个从从点vi到点vj的开销c(i,j)。路径v1v2…vn的开销是∑c(i,i+1)，其中1≦i≦n，这个开销通常被叫做权重路径长度（weighted path length）。无权重路径长度（unweighted path length）仅仅是路径上边的数目（n-1）</li>
<li>单源路径问题（单一路径问题，single-source shortest-path problem）<ul>
<li>给出一权重图，G = (V, E)，和一个节点s，找到图G中除s以外其它节点到s的最短权重路径</li>
<li>如果有负值权重并且路径中的一个循环（cycle）中带有负值权重，某个节点到另一个节点的最短路径是undefined的，因为没循环一次，cost就会降低，我们称这种情况为negative-cost cycle。负值权重和negative-cost cycle的出现不一定就是不好的，但是为了简便起见，这不讨论，而且规定s到s得最短路径长度为0</li>
</ul>
</li>
<li>很多例子中我们都想要解决最短路径问题，加入图中节点代表计算机，边代表计算机之间的连接，代价cost代表通信开销（communication cost，1000个byte需要的phone bill），延迟开销（delay cost，传输1000byte需要的时间-秒为单位），或者是以上或者其他一些开销的组合，我们可以使用最短路径算法来找到从一台计算机发送消息到另外一台计算机的最经济的方式</li>
<li>我们还可以使用图来将机场或者大规模公共交通线路建模并且使用最短路径算法计算两个节点间最好的线路，在很多实际问题中，我们都需要找到从某个确定的节点s到另外一个确定的节点t的最短路径。目前没有一个寻找从节点s到另一个确定节点的算法比寻找节点s到所有其它节点的最短路径这个算法快</li>
<li>我们将要考察解决上面四个不同版本最短路径问题的算法：首先，我们考虑无权重最短路径问题，并且展示如何在O(|E|+|V|)的时间内解决它。然后，我们展示如何解决假设没有负值权重的带权重最短路径问题，如果使用合理的数据结构，解决这个问题的时间复杂度为O(|E|log|V|)，如果有负值权重，我们给出一个简单地解决方案，但是时间复杂度为O(|E|*|V|)。最后我们在线性时间内解决特殊情况的带权重非循环图的相关问题</li>
<li>Unweighted Shortest Paths<ul>
<li>是weighted shortest path问题的一个特例，因为我们可以给每一条边的开销赋值为1</li>
<li>现在我们关注的重点是获得最短路径的长度，而不需要记录路径，记录实际路径实际上就是简单的登记工作（bookkeeping）</li>
<li>使用宽度优先搜索，一层一层的从内到外搜索s能通往的其它节点，这和树的按层遍历是一样的</li>
<li>对于这个算法，假设要寻找s到所有其它节点的最短路径，节点需要记录的信息有：<ul>
<li>一个记录所有节点到s节点的距离的数组，初始时，除了节点s本身，其它节点对于s都是不可达的，所以s到s本身的路径长度为0，s到其它节点的距离为∞</li>
<li>一个记录实际最短路径的数组</li>
<li>一个记录每个节点是否被处理过的布尔值数组，初始时，数组表示所有节点都未处理，包括源节点s</li>
</ul>
</li>
<li>当一个节点已经被处理过，我们能保证没有开销更低的路径了，也就是说这个节点的处理已经完成了</li>
<li>最原始的算法，基于上述初始化数据：<ul>
<li>首先遍历节点，找到所有没有被处理过并且路径长度为0（curr_dist=0）的节点（只有一个源节点s），将其是否被处理过的布尔值改为true，表示已经找到从s到s的最短路径，然后将所有于s相邻的节点并且路径长度为∞的节点的路径长度设置为1（curr_dist++），并且将记录实际最短路径数组相应位置设置为s</li>
<li>遍历节点，找到所有没有被处理过的并且路径长度为1（curr_dist=1）的节点v（上一步中所有和s相邻的节点），将其是否被处理过得布尔值改为true，表示已经找到从s到该节点的最短路径，然后将和v节点相邻并且和源点之间路径长度为∞的节点的路径长度设置为2（curr_dist++），并且将这些与v节点相邻的节点的记录实际最短路径的数组设置为v</li>
<li>重复这个步骤|V|-1次</li>
<li>这个算法的运行时间为O(|V|^2)，一个很明显的低效的地方就是这个程序一定在重复|V|-1次后才停止，即使所有的节点在很早的时候都已经被处理过了，虽然可以稍作修改使得上述情况改善，但是在最坏情况下（所有节点在一条路径上）还是会出现时间复杂度为O(|V|^2)的情况</li>
</ul>
</li>
<li>我们可以使用类似优化拓扑排序的方式来优化这个算法，由于任意时刻，只有两种没有被处理的并且路径长度不为∞的节点，一种路径长度为curr_dist，另一种为curr_dist++，由于这个额外的数据，我们可以减少一些无用的的表的遍历<ul>
<li>一个很简单但是很抽象的解决方案是创建两个box，box1记录所有路径长度为curr_dist的没有被处理过的节点，box2记录所有路径长度为curr_dist+1的节点</li>
<li>依然是循环|V|-1次，但是对路径长度为curr_dist的节点的查找在box1中，并且设置与查找到的节点（v）相邻节点的路径长度为curr_dist++（如果原来长度为∞的话），另外记录路径上的节点为v，重复这个过程将所有box1中路径长度为curr_dist的节点相邻节点加入到box2中，当box1为空时，将box2中节点转移到box1中重复进行上述过程</li>
</ul>
</li>
<li>对上面优化后的算法，我们可以进一步优化从而仅使用一个队列达到上述效果<ul>
<li>首先队列中包含路径长度为curr_dist的节点，然后我们将相邻节点（路径长度为curr_dist++的节点）加入队列（enqueue），因为队列是在队尾进行插入操作，所以我们可以保证在所有路径长度为curr_dist的节点被处理完之前，新加入队列路径长度为curr_dist++的节点是不会被处理的，这符合算法逻辑，当最后一个路径长度为curr_dist的节点按上述规则被处理完之后，队列就是包含有路径长度为curr_dist++的节点了，这个过程又可以在curr_dist++的基础上进行了。我们只需要在算法开始的时候将源节点（s）加入到队列中</li>
<li>对于这个算法，如果有从源节点不可达的其他节点，那么队列会提前为空，在这种情况下，某些节点的路径长度一直都是∞（INT_MAX），这也是合理的</li>
<li>使用和拓扑排序类似的分析方法，我们可以看到这个算法时间复杂度为O(|V|+|E|)</li>
</ul>
</li>
</ul>
</li>
<li>Dijkstra’s Algorithm<ul>
<li>对于权重图，我们可以从无权重图的算法中获得一些思路</li>
<li>我们保存和前面无权重图一样的信息：是否被处理过的布尔数组，每一个节点保存暂时的路径距离，最短路径只会用已经被处理过的节点作为路径中间的节点，同样，我们记录终点节点前一个节点（这个节点是最后一个改变终点节点的路径距离的节点）用来录实际的路径</li>
<li>这个一般的解决单源最短路径问题的算法被叫做Dijkstra’s Algorithm（狄克斯特拉算法），这个被创造三十年的算法是贪婪算法的典型例子，贪婪算法解决问题的策略是在每一步都使用貌似最好的结果，例如：在美元找零钱的时候，大多数人会先使用25美分硬币，然后10美分，然后5美分，最后1美分硬币，这样可以是用最少数量的硬币。贪婪算法最大的问题是它们并不是一直都有效的（比如说，找15美分，如果我们增加一个12美分面值的硬币，那么用贪婪算法的结果是12美分+3个一美分硬币，而最优的结果应该是10美分+5美分的硬币）</li>
<li>Dijkstra’s Algorithm的步骤和无权重图最短路径算法的步骤一样，首先在所有unknown节点中找出<strong>路径距离</strong>最小的节点v，并且设置节点v已经被处理（就是当前那个值），然后就要修改和它相邻的节点的路径距离了</li>
<li>在无权重图中，当与v相邻节点的距离为∞时，我们设置相邻节点的距离为curr_dist++，这本质上是如果通过v，源节点到与v相邻节点的距离减少了，我们就重新设置那个路径距离的值，我们在权重图上利用这个本质，我们计算与v相邻节点的距离dw = dv + cv，cv为v于其相邻节点之间的开销，如果这个新的距离，比原来的距离要小的话，我们就更新源点到与v相邻节点的路径距离，简单来说，算法决定从v通往于v相邻节点w这条路径是不是一个好的选择（距离大小）。原始的dw是路径中没有v节点时的开销，dv+cv是路径中含有v（和其他已经被处理过的节点）的最短路径的开销</li>
<li>重复上述步骤</li>
<li>如果要打印源点s到某一个节点v的最短路径，我们就要用到上述的记录实际最短路径的数组，因为路径数组中记录的都是最短路径中该节点v的上一个节点，所以我们可以写一个递归函数，将最短路径打印出来（一直递归到源节点s）</li>
<li>反证法可以证明如果没有负权重的边，这个算法是正确的，算法的运行时间跟如何操作我们记录的信息的那个Table，如果我们遍历表来找到当前路径距离最小的节点，那么每次循环都需要O(|V|)的时间来寻找那个节点，因此整个程序需要O(|V|^2)的时间来寻找最小路径距离的节点，更新路径距离的时间是常数，所以整个算法的时间复杂度为O(|E| + |V|^2)，如果是稠密图，也就是说|E| = O(|V|^2)，那么这个算法是可行的，因为它的运行时间和边数成线性相关；</li>
<li>如果图是稀疏的，例如|E| = O(|V|)，那么这个遍历寻找最小路径距离节点的算法就不可行了，在这种情况下，我们有两种方法来优化</li>
<li>一种方法是我们可以将路径距离数组存放在优先队列中，在原始的程序上需要做一些修改：寻找最小路径距离的节点使用优先队列的delete_min操作，因为每次寻找到一个最小路径距离的节点之后，我们不再需要那个节点（那个节点被标识为已处理），而更改节点路径距离的操作改为堆操作的decrease_key操作，delete_min和decrease_key操作的时间复杂度都为O(log|V|)，因为修改后算法的时间复杂度为O(|E|log|V| + |V|log|V|) = O(|E|log|V|)，这样比前面实现的时间复杂度要低，由于优先队列没有find操作，因此每一个路径距离对应在优先队列中的位置必须记录下来，并且当路径距离更新的时候，相应位置记录也得更新，这不属于优先队列的ADT，因此代码是比较丑陋的</li>
<li>另一种方法是每当有某个节点w和新的路径距离dw更新时，都加入到优先队列中，因为在优先队列中，每个节点可能会出现多次（对应多个路径距离），每次对优先队列的delete_min操作都需要保证被删除的最小路径距离的节点是未被处理的（因此寻找最小路径距离节点的操作变成了delete_min操作的循环，这个循环直到找到了一个未被处理的节点），尽管这个方法从软件的角度来看是更优的，并且更容易编码，但是可能导致优先队列大小变得和边的数目|E|一样大，这并不影响时间复杂度（优先队列由于增大，其操作时间复杂度会变化），因为|E|≤|V|^2（需要注意的关系是|V|&lt;|E|≤|V|^2），所以log|E|≤2log|V|（优先队列增大，但是时间复杂度还是小于log|V|），因此时间复杂度仍然为O(|E|log|V|)，但是空间需求确实增大了，这在某些应用中可能是需要考虑的一点，另外由于这个方法需要|E|次delete_min操作而不仅仅是|V|次，所以实际中可能会慢一点</li>
<li>同样我们观察到在一些典型的实际问题中，比如计算机邮件和公共交通系统，它们对应的图模型都是非常稀疏的因为大部分节点都只有两三条边，因此很多问题中都需要使用优先队列来优化算法</li>
<li>最后，我们还能找到让时间复杂度更低的优化方法：在第11章，我们将介绍一种叫做斐波那契堆的优先队列数据结构，利用它，算法时间复杂度为O(|E| + |V|log|V|)。斐波那契堆在理论上有很好的时间复杂度，但是在实际应用中，并不能保证它比一般的优先队列要好</li>
<li>另外也没有平均情况能考虑，因为随机图并不是那么明显地可以定义</li>
</ul>
</li>
<li>Graphs with Negative Edge Costs<ul>
<li>如果图中含有权重为负值的边，那么上面的狄克斯特拉算法就没用了，愿意是，如果将某个节点设置为已经被处理过，但是可能从某个未处理过的节点v有一条边通往u并且这条边的距离是很大的负数，这种情况下，选择从s到v并且再到u比从s不经过v到u要更好</li>
<li>一个结合权重图和非权重图的算法可以解决这个问题，但是会急剧增加运算时间</li>
<li>我们忽略节点是否被处理过这一信息</li>
<li>首先，我们将源节点s加入队列，然后在每一步，我们将一个节点v移出队列，找到v的相邻节点w，并且如果w原来的路径距离dw &gt; dv + cvw，那么我们就更新w的路径距离，并且将w加入队列，如果w没有在队列中（我们可以给每个节点添加一位来表示是否在队列中），我们重复上述步骤，直到队列为空</li>
<li>这个算法在没有负值权重的图也可以用，但是每一个节点最多可能移出队列|V|次，所以如果使用邻接表的画，时间复杂度为O(|E|*|V|)，幸运的是，现实应用中，边的开销（权重）一般都是非负的，如果带有负权值的循环（cycle），那么就会出现无限循环。当任意节点被移除队列|V|+1次后，我们可以强行停止算法执行（因为可以确定出现了负权值的循环）</li>
</ul>
</li>
<li>Acyclic Graphs<ul>
<li>如果图是确定为非循环图，那么我们可以通过改变节点被处理的顺序来优化狄克斯特拉算法，也就是说制定选择节点的规则，新的规则是，按照拓扑排序来选择节点，由于节点的选择是根据拓扑排序来的，所以原来算法的选择当前路径距离最短的节点和更新与其相邻节点的距离可以被拓扑排序代替，因此，整个算法也只需要一次遍历拓扑排序后的序列就行</li>
<li>这个选择规则是正确的，因为如果按照拓扑排序序列来选择节点，当某个节点v被选择处理时，v节点的路径距离不会再减少，因为所有拓扑排序排在v前面的节点已经被处理，而未处理的节点是不会有边通向v节点的（由于拓扑排序的定义）</li>
<li>这个算法也不需要优先队列，时间复杂度为O(|E|+|V|)，因为从优先队列中选择节点只需要常数时间</li>
<li>非循环图能够为某些下坡滑雪问题（downhill skiing problem）建模，我们想从a到b，但是只能通过下坡到达，所以显然这是没有循环的（只往下不往上）。另一种应用是不可逆的化学反应建模，我们可以把每一个节点看做是实验的某一个状态，边代表从某一个状态到另一个状态的转换，边的权重可以看做是反应中释放的能量，如果只有从高能量转换到低能量的转换是允许的，那么图是非循环的</li>
<li>非循环图中最重要的一个应用是关键路径分析（critical path analysis），与之相关的图叫活动节点图（activity-node graph），每个节点表示需要完成的活动和完成这个活动需要的时间，每条边代表活动的先后顺序，如(v, w)表示v活动需要在w活动开始之前之前完成，这也就说明这种模型的图也是非循环的，假设活动之前没有相互的依赖关系，并且不同活动可以在满足先后顺序的条件下并行地在不同服务器上执行</li>
<li>这种类型的图，可以并且通常就是用来对建筑工程活动进行建模，在这种例子中，有几个重要而且有意思的问题是有必要解答的，第一个便是，工程最早能在什么时候完工，另一个问题是，哪一个活动在不影响最快完工时间的情况下是可以推迟的，并且可以推迟多久？</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <footer>
      <div class="alignleft">
      
  
  <div class="categories">
    <a href="/categories/Algorithm/">Algorithm</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/graph/">graph</a>
  </div>

      </div>
      <div class="clearfix"></div>
    </footer>
    
  </div>
</article>


<section id="comment">
  
            <!-- Duoshuo Comment BEGIN -->
            <div class="ds-thread"></div>
            <script type="text/javascript">
                var duoshuoQuery = {short_name:"jjliu"};
                (function() {
                    var ds = document.createElement('script');
                    ds.type = 'text/javascript';ds.async = true;
                    ds.src = 'http://static.duoshuo.com/embed.js';
                    ds.charset = 'UTF-8';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
                })();
            </script>
            <!-- Duoshuo Comment END -->
      
  
</section>

</div></div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer"><div class="inner"><div class="alignleft">
  <p>
  
    &copy; 2014 Jin Liu
  
  </p>
  <p>
   Theme By <a href="http://www.jjliu.tk" >Jin</a>
   based on <a href="http://github.com/willerce/hexo-theme-noderce">Noderce</a>
  </p>

</div>
<div class="clearfix"></div>
</div></footer>
  <script type="text/javascript">

</script>

</body>
</html>
