<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Jin › 第十篇-Data Structures and Algorithm Analysis in C-第九章笔记</title>
  <meta name="author" content="Jin Liu">
  
  <meta name="description" content="在看Data Structures and Algorithm Analysis in C: Second Edition 第九章GRAPH ALGORITHM，以下记录自己新的理解
GRAPH ALGORITHM
本章我们主要讨论图理论中几个常见的问题。这些问题不仅因为它们确实很有用，另外，在实际的应用程序中如果不仔细注意选择数据结构，这些应用运行非常慢">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="第十篇-Data Structures and Algorithm Analysis in C-第九章笔记"/>
  <meta property="og:site_name" content="Jin"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Jin" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-32857089-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">Jin</a></h1>
  <h2><a href="/">Newer@Computer</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">关于我</a></li>
      
      <li><a href="/archives">文章归档</a></li>
      
      <li><a href="/links">相关链接</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title">第十篇-Data Structures and Algorithm Analysis in C-第九章笔记</h1>
  

      
      <time datetime="2014-09-10T07:29:53.000Z">9月 10 2014</time>
      
    </header>
    <div class="entry">
      
        <p><em>在看Data Structures and Algorithm Analysis in C: Second Edition 第九章GRAPH ALGORITHM，以下记录自己新的理解</em></p>
<h1 id="GRAPH_ALGORITHM">GRAPH ALGORITHM</h1>
<p>本章我们主要讨论图理论中几个常见的问题。这些问题不仅因为它们确实很有用，另外，在实际的应用程序中如果不仔细注意选择数据结构，这些应用运行非常慢<br><a id="more"></a></p>
<h2 id="我们将：">我们将：</h2>
<ul>
<li>展示一些实际生活中能够转换到图理论上的问题</li>
<li>给出解决几个常见问题的算法</li>
<li>展示正确的数据结构选择是能够直接地减少算法的运行时间的</li>
<li>展示一个重要的技术，深度优先算法，并观察它怎样在线性时间内解决一些看上去非平凡的问题</li>
</ul>
<h2 id="关键点：_"><strong>关键点： </strong></h2>
<ul>
<li>Definitions<ul>
<li>图G = (V, E)包含一个点（vertices）集V，一个边（edge）集E，每一条边是一个点对(v, w)，其中v，w∈V。边有时也叫做弧（arcs），如果组成边的点对是有序的，那么图就是有向图，有向图通常叫做digraph，点w和点v是紧邻的（vertex w is adjacent to v），当且仅当(v, w)∈V。在无向图（undirected graph）中，如果有边(v, w)，那么也有边(w, v)，点w和点v紧邻，并且点v和点w紧邻。有时候，边还有一个属性，叫做边的权重（weight或cost）</li>
<li>图中的路径（path）是一串顶点w1，w2，w3，…，wn，并且对于 1≤ i &lt;n，有(wi, wi+1)∈E，path的长度就是路径中边的个数，等于n-1。我们允许一条路径从某个顶点出发，不经过其它顶点就回到自身，这个路径不包括边，所以路径长度为0，通常用它来处理一些特殊情况</li>
<li>如果图里包含一条边(v, v)，那么路径v,v被叫做一个loop，我们通常考虑的图是没有loop的，一个简单路径（simple path）是指路径中的所有顶点都是不同的，除了第一个和最后一个顶点可以一样</li>
<li>一个cycle是指有向图中长度大于1并且w1=wn的一条路径，当这个cycle对应的路径（path）是简单的（simple path），那么我们说cycle是简单的（simple cycle），对于无向图，cycle另外要求，路径中没有相同的边，因此无向图中路径u，v，u  不是cycle，因为在无向图中(u, v)和(v, u)是同一条边，在有向图中，该路径可以说是一个cycle，因为无向图中(u, v)，(v, u)是两条不同的边。如果图中不存在cycle，那么这个图就叫做非循环的（acyclic），一个非循环的有向图，通常叫做DAG（directed acyclic graph）</li>
<li>如果一个无向图中，每一个节点都有通到所有其他节点的路径，那么我们称这个无向图为连通的（connected），满足上述条件的有向图我们称它是强连通（strong connected）的。如果一个有向图不是强连通的，但是它对应的基础图（忽略边的方向，有向图的点和边组成的无向图）是连通的，那么我们称它为弱连通（weakly connectd）的。如果图中的每一对节点之间都有一条边，那么我们就称这个图是完全图（complete graph）</li>
<li>机场系统是现实情景中可以用图来建模的例子，每一个机场是一个节点，如果代表机场的两个节点间有一个没有中间停靠站的航线，那么这两个节点间就有一条边，边上可能会有权重，可以代表时间，距离，或者飞行成本。，因为从另一点出发可能所花时间更长或者成本更高（例如不同地区的税不同），所以认为这个模型是有向图是有道理的。也可以保证一般的机场系统是强连通的，所以从任何一个机场飞到任何另一个机场都是可能的。因此我们希望快速的找到最好的一条路径，所谓最好路径，是指路径中的边最少，或者根据路径中某一个或者所有边的权重来衡量</li>
<li>交通网也可以用图来建模。每一个十字路口代表一个节点，每条街代表一条边，边的权重可以表示：限制速度，车道数量等指标。我们因此可以找到最短路线或者找到交通瓶颈的位置</li>
<li>本章接下来将会看一些图的更多应用。这些应用对应的图模型都很大，所以图算法的效率至关重要</li>
<li>Representation of Graphs<ul>
<li>我们讨论有向图的表示方法（无向图类似）</li>
<li>一个简单的表示图的方法就是用一个二维数组，通常被叫做邻接矩阵（adjacency matrix），对每一条边(u, v)，我们设置a[u][v]=1，否者数组中该项设置为0，如果图中的边是有权重的，那么我们将a[u][v]设置为边的权重，并且使用一个非常大或者非常小的权重来作为哨兵（sentinel）表示不存在该边（无权重邻接表中的0）。例如，如果我们要找到最便宜的航线，我们可以将不存在的边对应的邻接表中的值设置为∞。如果我们需要找到最昂贵的飞行路线，我们可以使用-∞或者0来表示不存在的边</li>
<li>尽管使用邻接矩阵非常简单，但是空间复杂度是Θ(|V|^2)，只有当图没有太多条边的时候，这个条件可以允许。当图的密度很大（dense）的时候（当|E|=Θ(|V|^2)的时候，这样邻接矩阵中的大部分元素都是有意义的，不是大部分元素的值都是代表没有边的0，或者正负无穷），邻接矩阵表示法是适当的，但是很多情况下，这个条件是不满足的</li>
<li>如果图密度不大，换而言之，图是稀疏的（sparse），一个更好的方案是使用邻接表。对于任何一个节点，我们用一个链表记录所有和它相邻的其它节点，这个表示方法的空间复杂度为O(|E| + |V|)，如果边有权重，那么也可以记录在表示节点的结构中</li>
<li>邻接表是表示图的标准方法，无向图也可以类似的表示，每一条边(u, v)都出现在两个链表中，因此空间需求也是两倍。图算法中一个常见的需求就是找出和某个节点v相邻的所有其它节点，使用这个表示方法，这个需求可以只通过遍历一遍正确的邻接表就可以，在实际应用中，图中的节点是有名字的而不仅是数字，并且在编译阶段它们是未知的。因为名字未知，所以不能定义一个名字数组，因此我们需要将未知的名字映射到数字上，最简单的办法就是用hash表。过程是这样的：在hash表中，当读取图进行初始化时候，对于每一个节点，我们存放它的名字和范围从1到|V|的相应序号，比如当读取一条边时，我们检查边的两个节点是否在hash表中分配了序号，如果已经分配了序号，我们就使用已经分配的序号，否则我们分配这个节点下一个可用的序号，并且将节点名和序号存放在hash表中，使用这个转化，所有图算法都能使用内部序号。因为最终我们要输出节点的真实名字而不是内部序号，所以对于每一个内部序号，我们需要记录它对应的节点名字，一种方法是使用字符串数组，但是如果节点名字太长，这将消耗大量内存，因为每个节点的名字都存了两遍。另一种方法是用一个指向hash表中的记录的指针数组，这稍微破坏了哈希表的抽象数据类型（ADT）</li>
</ul>
</li>
</ul>
</li>
<li>Topological Sort<ul>
<li>拓扑排序是指有向非循环图中节点的顺序，如果有一条从vi到vj的路径，那么vj就排在vi后面</li>
<li>如果图中含有循环cycle，那么拓扑排序是不可能的，因为对于在一个cycle中的两个节点v和w，可以说v排在w的前面，也可以说w排在v前面。此外，图中拓扑排序序列也不是唯一的，任何符合拓扑排序规则的都是正确的</li>
<li>一个简单的寻找拓扑排序序列的算法是：首先找到任意一个入度为0的节点，打印这个节点并且从图中删除它和它关联的边。然后我们对图一直重复这个过程<ul>
<li>这个简单算法，需要一个记录V个节点入度的数组，每次遍历这个数组找到入度为0的节点，并且删除它，减少和这个节点邻接的其它节点的入度，遍历一次入度数组的时间复杂度为O(|V|)，而这个算法需要重复这个过程|V|次，所以时间复杂度为O(|V|^2)</li>
</ul>
</li>
<li>基于上面的算法，另一种考虑是，一般图是稀疏的（sparse），因此当删除一个节点的时候，不是所有其它节点都需要更新入度，然而在上面的算法中，为了找到一个入度为0的节点，我们遍历了整个数组，实际上对这点是可以优化的<ul>
<li>优化方法是，我们使用一个数组（数据结构上可以是队列也可以是堆栈）记录所有入度为0的节点，我们从这个数组中选择入度为0的节点，删除它，并且减少与它相邻节点的入度，如果某些节点的入度也变为0，我们有将这些节点加入到记录入度为0节点的数组中（队列或者是堆栈），这样就消除了上面那个算法中，每次都遍历整个入度数组的低效的缺点</li>
<li>优化后的算法的时间复杂度为O(|E|+|V|)，因为删除节点对入度的修改，最多对每条边执行一次，另外每个节点加入队列或者堆栈和从队列或者堆栈中删除（enqueue &amp; dequeue）最多一次，而且初始化计算入度和建立入度为0的数组的时间复杂度也只是和图的规模有关</li>
</ul>
</li>
</ul>
</li>
<li>Shortest-Path Algorithms<ul>
<li>这一节，将介绍各种最短路径算法。输入是权重图（weighted graph）：每一条边(vi, vj)都有一个从从点vi到点vj的开销c(i,j)。路径v1v2…vn的开销是∑c(i,i+1)，其中1≦i≦n，这个开销通常被叫做权重路径长度（weighted path length）。无权重路径长度（unweighted path length）仅仅是路径上边的数目（n-1）</li>
<li>单源路径问题（单一路径问题，single-source shortest-path problem）<ul>
<li>给出一权重图，G = (V, E)，和一个节点s，找到图G中除s以外其它节点到s的最短权重路径</li>
<li>如果有负值权重并且路径中的一个循环（cycle）中带有负值权重，某个节点到另一个节点的最短路径是undefined的，因为没循环一次，cost就会降低，我们称这种情况为negative-cost cycle。负值权重和negative-cost cycle的出现不一定就是不好的，但是为了简便起见，这不讨论，而且规定s到s得最短路径长度为0</li>
</ul>
</li>
<li>很多例子中我们都想要解决最短路径问题，加入图中节点代表计算机，边代表计算机之间的连接，代价cost代表通信开销（communication cost，1000个byte需要的phone bill），延迟开销（delay cost，传输1000byte需要的时间-秒为单位），或者是以上或者其他一些开销的组合，我们可以使用最短路径算法来找到从一台计算机发送消息到另外一台计算机的最经济的方式</li>
<li>我们还可以使用图来将机场或者大规模公共交通线路建模并且使用最短路径算法计算两个节点间最好的线路，在很多实际问题中，我们都需要找到从某个确定的节点s到另外一个确定的节点t的最短路径。目前没有一个寻找从节点s到另一个确定节点的算法比寻找节点s到所有其它节点的最短路径这个算法快</li>
<li>我们将要考察解决上面四个不同版本最短路径问题的算法：首先，我们考虑无权重最短路径问题，并且展示如何在O(|E|+|V|)的时间内解决它。然后，我们展示如何解决假设没有负值权重的带权重最短路径问题，如果使用合理的数据结构，解决这个问题的时间复杂度为O(|E|log|V|)，如果有负值权重，我们给出一个简单地解决方案，但是时间复杂度为O(|E|*|V|)。最后我们在线性时间内解决特殊情况的带权重非循环图的相关问题</li>
<li>Unweighted Shortest Paths<ul>
<li>是weighted shortest path问题的一个特例，因为我们可以给每一条边的开销赋值为1</li>
<li>现在我们关注的重点是获得最短路径的长度，而不需要记录路径，记录实际路径实际上就是简单的登记工作（bookkeeping）</li>
<li>使用宽度优先搜索，一层一层的从内到外搜索s能通往的其它节点，这和树的按层遍历是一样的</li>
<li>对于这个算法，假设要寻找s到所有其它节点的最短路径，节点需要记录的信息有：<ul>
<li>一个记录所有节点到s节点的距离的数组，初始时，除了节点s本身，其它节点对于s都是不可达的，所以s到s本身的路径长度为0，s到其它节点的距离为∞</li>
<li>一个记录实际最短路径的数组</li>
<li>一个记录每个节点是否被处理过的布尔值数组，初始时，数组表示所有节点都未处理，包括源节点s</li>
</ul>
</li>
<li>当一个节点已经被处理过，我们能保证没有开销更低的路径了，也就是说这个节点的处理已经完成了</li>
<li>最原始的算法，基于上述初始化数据：<ul>
<li>首先遍历节点，找到所有没有被处理过并且路径长度为0（curr_dist=0）的节点（只有一个源节点s），将其是否被处理过的布尔值改为true，表示已经找到从s到s的最短路径，然后将所有于s相邻的节点并且路径长度为∞的节点的路径长度设置为1（curr_dist++），并且将记录实际最短路径数组相应位置设置为s</li>
<li>遍历节点，找到所有没有被处理过的并且路径长度为1（curr_dist=1）的节点v（上一步中所有和s相邻的节点），将其是否被处理过得布尔值改为true，表示已经找到从s到该节点的最短路径，然后将和v节点相邻并且和源点之间路径长度为∞的节点的路径长度设置为2（curr_dist++），并且将这些与v节点相邻的节点的记录实际最短路径的数组设置为v</li>
<li>重复这个步骤|V|-1次</li>
<li>这个算法的运行时间为O(|V|^2)，一个很明显的低效的地方就是这个程序一定在重复|V|-1次后才停止，即使所有的节点在很早的时候都已经被处理过了，虽然可以稍作修改使得上述情况改善，但是在最坏情况下（所有节点在一条路径上）还是会出现时间复杂度为O(|V|^2)的情况</li>
</ul>
</li>
<li>我们可以使用类似优化拓扑排序的方式来优化这个算法，由于任意时刻，只有两种没有被处理的并且路径长度不为∞的节点，一种路径长度为curr_dist，另一种为curr_dist++，由于这个额外的数据，我们可以减少一些无用的的表的遍历<ul>
<li>一个很简单但是很抽象的解决方案是创建两个box，box1记录所有路径长度为curr_dist的没有被处理过的节点，box2记录所有路径长度为curr_dist+1的节点</li>
<li>依然是循环|V|-1次，但是对路径长度为curr_dist的节点的查找在box1中，并且设置与查找到的节点（v）相邻节点的路径长度为curr_dist++（如果原来长度为∞的话），另外记录路径上的节点为v，重复这个过程将所有box1中路径长度为curr_dist的节点相邻节点加入到box2中，当box1为空时，将box2中节点转移到box1中重复进行上述过程</li>
</ul>
</li>
<li>对上面优化后的算法，我们可以进一步优化从而仅使用一个队列达到上述效果<ul>
<li>首先队列中包含路径长度为curr_dist的节点，然后我们将相邻节点（路径长度为curr_dist++的节点）加入队列（enqueue），因为队列是在队尾进行插入操作，所以我们可以保证在所有路径长度为curr_dist的节点被处理完之前，新加入队列路径长度为curr_dist++的节点是不会被处理的，这符合算法逻辑，当最后一个路径长度为curr_dist的节点按上述规则被处理完之后，队列就是包含有路径长度为curr_dist++的节点了，这个过程又可以在curr_dist++的基础上进行了。我们只需要在算法开始的时候将源节点（s）加入到队列中</li>
<li>对于这个算法，如果有从源节点不可达的其他节点，那么队列会提前为空，在这种情况下，某些节点的路径长度一直都是∞（INT_MAX），这也是合理的</li>
<li>使用和拓扑排序类似的分析方法，我们可以看到这个算法时间复杂度为O(|V|+|E|)</li>
</ul>
</li>
</ul>
</li>
<li>Dijkstra’s Algorithm<ul>
<li>对于权重图，我们可以从无权重图的算法中获得一些思路</li>
<li>我们保存和前面无权重图一样的信息：是否被处理过的布尔数组，每一个节点保存暂时的路径距离，最短路径只会用已经被处理过的节点作为路径中间的节点，同样，我们记录终点节点前一个节点（这个节点是最后一个改变终点节点的路径距离的节点）用来录实际的路径</li>
<li>这个一般的解决单源最短路径问题的算法被叫做Dijkstra’s Algorithm（狄克斯特拉算法），这个被创造三十年的算法是贪婪算法的典型例子，贪婪算法解决问题的策略是在每一步都使用貌似最好的结果，例如：在美元找零钱的时候，大多数人会先使用25美分硬币，然后10美分，然后5美分，最后1美分硬币，这样可以是用最少数量的硬币。贪婪算法最大的问题是它们并不是一直都有效的（比如说，找15美分，如果我们增加一个12美分面值的硬币，那么用贪婪算法的结果是12美分+3个一美分硬币，而最优的结果应该是10美分+5美分的硬币）</li>
<li>Dijkstra’s Algorithm的步骤和无权重图最短路径算法的步骤一样，首先在所有unknown节点中找出<strong>路径距离</strong>最小的节点v，并且设置节点v已经被处理（就是当前那个值），然后就要修改和它相邻的节点的路径距离了</li>
<li>在无权重图中，当与v相邻节点的距离为∞时，我们设置相邻节点的距离为curr_dist++，这本质上是如果通过v，源节点到与v相邻节点的距离减少了，我们就重新设置那个路径距离的值，我们在权重图上利用这个本质，我们计算与v相邻节点的距离dw = dv + cv，cv为v于其相邻节点之间的开销，如果这个新的距离，比原来的距离要小的话，我们就更新源点到与v相邻节点的路径距离，简单来说，算法决定从v通往于v相邻节点w这条路径是不是一个好的选择（距离大小）。原始的dw是路径中没有v节点时的开销，dv+cv是路径中含有v（和其他已经被处理过的节点）的最短路径的开销</li>
<li>重复上述步骤</li>
<li>如果要打印源点s到某一个节点v的最短路径，我们就要用到上述的记录实际最短路径的数组，因为路径数组中记录的都是最短路径中该节点v的上一个节点，所以我们可以写一个递归函数，将最短路径打印出来（一直递归到源节点s）</li>
<li>反证法可以证明如果没有负权重的边，这个算法是正确的，算法的运行时间跟如何操作我们记录的信息的那个Table，如果我们遍历表来找到当前路径距离最小的节点，那么每次循环都需要O(|V|)的时间来寻找那个节点，因此整个程序需要O(|V|^2)的时间来寻找最小路径距离的节点，更新路径距离的时间是常数，所以整个算法的时间复杂度为O(|E| + |V|^2)，如果是稠密图，也就是说|E| = O(|V|^2)，那么这个算法是可行的，因为它的运行时间和边数成线性相关；</li>
<li>如果图是稀疏的，例如|E| = O(|V|)，那么这个遍历寻找最小路径距离节点的算法就不可行了，在这种情况下，我们有两种方法来优化</li>
<li>一种方法是我们可以将路径距离数组存放在优先队列中，在原始的程序上需要做一些修改：寻找最小路径距离的节点使用优先队列的delete_min操作，因为每次寻找到一个最小路径距离的节点之后，我们不再需要那个节点（那个节点被标识为已处理），而更改节点路径距离的操作改为堆操作的decrease_key操作，delete_min和decrease_key操作的时间复杂度都为O(log|V|)，因为修改后算法的时间复杂度为O(|E|log|V| + |V|log|V|) = O(|E|log|V|)，这样比前面实现的时间复杂度要低，由于优先队列没有find操作，因此每一个路径距离对应在优先队列中的位置必须记录下来，并且当路径距离更新的时候，相应位置记录也得更新，这不属于优先队列的ADT，因此代码是比较丑陋的</li>
<li>另一种方法是每当有某个节点w和新的路径距离dw更新时，都加入到优先队列中，因为在优先队列中，每个节点可能会出现多次（对应多个路径距离），每次对优先队列的delete_min操作都需要保证被删除的最小路径距离的节点是未被处理的（因此寻找最小路径距离节点的操作变成了delete_min操作的循环，这个循环直到找到了一个未被处理的节点），尽管这个方法从软件的角度来看是更优的，并且更容易编码，但是可能导致优先队列大小变得和边的数目|E|一样大，这并不影响时间复杂度（优先队列由于增大，其操作时间复杂度会变化），因为|E|≤|V|^2（需要注意的关系是|V|&lt;|E|≤|V|^2），所以log|E|≤2log|V|（优先队列增大，但是时间复杂度还是小于log|V|），因此时间复杂度仍然为O(|E|log|V|)，但是空间需求确实增大了，这在某些应用中可能是需要考虑的一点，另外由于这个方法需要|E|次delete_min操作而不仅仅是|V|次，所以实际中可能会慢一点</li>
<li>同样我们观察到在一些典型的实际问题中，比如计算机邮件和公共交通系统，它们对应的图模型都是非常稀疏的因为大部分节点都只有两三条边，因此很多问题中都需要使用优先队列来优化算法</li>
<li>最后，我们还能找到让时间复杂度更低的优化方法：在第11章，我们将介绍一种叫做斐波那契堆的优先队列数据结构，利用它，算法时间复杂度为O(|E| + |V|log|V|)。斐波那契堆在理论上有很好的时间复杂度，但是在实际应用中，并不能保证它比一般的优先队列要好</li>
<li>另外也没有平均情况能考虑，因为随机图并不是那么明显地可以定义</li>
</ul>
</li>
<li>Graphs with Negative Edge Costs<ul>
<li>如果图中含有权重为负值的边，那么上面的狄克斯特拉算法就没用了，愿意是，如果将某个节点设置为已经被处理过，但是可能从某个未处理过的节点v有一条边通往u并且这条边的距离是很大的负数，这种情况下，选择从s到v并且再到u比从s不经过v到u要更好</li>
<li>一个结合权重图和非权重图的算法可以解决这个问题，但是会急剧增加运算时间</li>
<li>我们忽略节点是否被处理过这一信息</li>
<li>首先，我们将源节点s加入队列，然后在每一步，我们将一个节点v移出队列，找到v的相邻节点w，并且如果w原来的路径距离dw &gt; dv + cvw，那么我们就更新w的路径距离，并且将w加入队列，如果w没有在队列中（我们可以给每个节点添加一位来表示是否在队列中），我们重复上述步骤，直到队列为空</li>
<li>这个算法在没有负值权重的图也可以用，但是每一个节点最多可能移出队列|V|次，所以如果使用邻接表的画，时间复杂度为O(|E|*|V|)，幸运的是，现实应用中，边的开销（权重）一般都是非负的，如果带有负权值的循环（cycle），那么就会出现无限循环。当任意节点被移除队列|V|+1次后，我们可以强行停止算法执行（因为可以确定出现了负权值的循环）</li>
</ul>
</li>
<li>Acyclic Graphs<ul>
<li>如果图是确定为非循环图，那么我们可以通过改变节点被处理的顺序来优化狄克斯特拉算法，也就是说制定选择节点的规则，新的规则是，按照拓扑排序来选择节点，由于节点的选择是根据拓扑排序来的，所以原来算法的选择当前路径距离最短的节点和更新与其相邻节点的距离可以被拓扑排序代替，因此，整个算法也只需要一次遍历拓扑排序后的序列就行</li>
<li>这个选择规则是正确的，因为如果按照拓扑排序序列来选择节点，当某个节点v被选择处理时，v节点的路径距离不会再减少，因为所有拓扑排序排在v前面的节点已经被处理，而未处理的节点是不会有边通向v节点的（由于拓扑排序的定义）</li>
<li>这个算法也不需要优先队列，时间复杂度为O(|E|+|V|)，因为从优先队列中选择节点只需要常数时间</li>
<li>非循环图能够为某些下坡滑雪问题（downhill skiing problem）建模，我们想从a到b，但是只能通过下坡到达，所以显然这是没有循环的（只往下不往上）。另一种应用是不可逆的化学反应建模，我们可以把每一个节点看做是实验的某一个状态，边代表从某一个状态到另一个状态的转换，边的权重可以看做是反应中释放的能量，如果只有从高能量转换到低能量的转换是允许的，那么图是非循环的</li>
<li>非循环图中最重要的一个应用是关键路径分析（critical path analysis），与之相关的图叫活动节点图（activity-node graph），每个节点表示需要完成的活动和完成这个活动需要的时间，每条边代表活动的先后顺序，如(v, w)表示v活动需要在w活动开始之前之前完成，这也就说明这种模型的图也是非循环的，假设活动之前没有相互的依赖关系，并且不同活动可以在满足先后顺序的条件下并行地在不同服务器上执行</li>
<li>这种类型的图，可以并且通常就是用来对建筑工程活动进行建模，在这种例子中，有几个重要而且有意思的问题是有必要解答的，第一个便是，工程最早能在什么时候完工，另一个问题是，哪一个活动在不影响最快完工时间的情况下是可以推迟的，并且可以推迟多久？</li>
<li>为了执行以上计算获得答案，我们将活动节点图（activity-node graph）转变成事件节点图（event-node graph），每一个事件对应一个活动和所有它依赖的活动的完成,边对应某个活动和活动完成所需时间。在事件节点图中，从一个节点v能够到达的其它事件在事件v完成之前是不会开始的，事件节点图可以自动也可以手动转换得到，由于一个活动可能依赖多个其他活动，所以一些额外附加的节点和边可能需要被插入到图中</li>
<li>为了找到工程最早的完成时间，我们只需要找到从第一个节点到最后一个节点的最长路径，对于一般的图，由于可能出现正权重的循环，最长路径问题一般没有意义，这和最短路径中的负权重循环是一个道理，但是由于事件节点图是非循环的，我们不用担心上面的问题，在这种情况下，很容易将最短路径算法进行修改来找到工程最早完成时间，如果ECi是i节点的最早完成时间，那么规则如下：<ul>
<li>EC1 = 0</li>
<li>ECw = max(ECv + Cvw)，边(v, w) ∈ E</li>
</ul>
</li>
<li>我们也可以计算最晚完成时间，LCi，它表示每个事件最迟可以在什么时候完成，并且不会影响上面计算的最终最早完成时间，规则如下：<ul>
<li>LCn = ECn</li>
<li>LCv = min(LCw - Cvw)，边(v, w) ∈ E</li>
</ul>
</li>
<li>这些值可以在线性时间内算出来，如果对于每个节点，我们记录所有与它相邻的节点和所有指向它的前一个节点，最早完成时间是按照拓扑顺序计算的，最晚完成事件是按照拓扑顺序的逆序计算的</li>
<li>事件节点图中每条边的松弛时间（slack time）代表相应活动在不影响整体完成事件的情况下可以推迟完成的时间，很容易的到Slack(v,w) = LCw - ECv - Cvw</li>
<li>某些活动的slack time为0，这些活动就是关键活动（critical activities），这些活动必须按照预定时间完成，整个图中至少存在一条路径上的所有边的延迟时间都未0，这中路径就叫做关键路径</li>
</ul>
</li>
<li>All-Pairs Shortest Path<ul>
<li>有时候，我们需要计算途中任何一对节点之间的最短路径，尽管我们可以对每一个节点运行一次单源算法（运行|V|次），但是我们期望可以找到更快的算法，特别是在稠密图（dense graph）中</li>
<li>在第十章中，我们将考虑一个O(|V|^3)的算法解决权重图中的这个问题，尽管在稠密图中，这个复杂度和运行|V|次狄克斯特拉算法的复杂度一样，但是由于更紧凑的循环使得实际应用中该算法更快，在稀疏图中，运行|V|次使用优先队列实现的狄克斯特拉算法要更快</li>
</ul>
</li>
</ul>
</li>
<li>Network Flow Problems<ul>
<li>假设我们有有向权重图G=(V, E)，边的权重为Cvw，权重可以用来表示管道中水流可以流过的量或者两个十字路口间的街道可以通过的车流量。我们有两个节点，节点s，叫做源点，节点t，叫做水槽sink。任意一条边(v, w)，最多Cvw单位的量可以通过，在任意一个非s和非t的节点，总共流入量必须等于总共的流出量，最大流量问题（maximum flow problem）是指计算从s到t的最大流量</li>
<li>由问题条件限制，节点不能够容纳多于其容量的流量（输入为所有入度的流量和，输出为所有出度边的流量和，输入要和输出相等），每个节点可以任意从多个节点获得流量，也可以向多个节点分发流量，只要符合输入输出流量相等原则</li>
<li>A Simple Maximum-Flow Algorithm<ul>
<li>分阶段尝试解决上述最大流量问题，从我们的图开始，建立一个流量图Gf，Gf记录算法的每一步中的流量，初始的时候，Gf中任何一条边都没有流量，并且我们希望当算法结束时，Gf中含有最大流量。我们还建立一个图Gr，叫做剩余图（residual graph），Gr图记录每一条边还能加入多少流量，我们可以用<strong>每一条边的容量减去该边当前流量</strong>来计算这个值，Gr中的边又没称做剩余边（residual edge）</li>
<li>在每一阶段，我们从Gr中找到一条从s到t得路径，这条路径叫做增广路径    （argumenting path），这条路径上的最小边，就是这条路径上每条边能够添加的流量，我们通过调整Gf来添加流量，并且重新计算Gr。如果我们在Gr中找不到从s到t得路径，算法停止。因为我们随意挑选Gr中s到t的路径，所以这个算法是非确定性的（nondeterministic），而且可能会出现错误（贪婪算法错误的例子），很显然有些挑选方法要更好，后面我们会解决这个问题</li>
<li>要改正上面错误（贪婪算法的错误），我们需要算法能够改变其开始的选择，当我们从Gr中选出一条路径之后，并且重新计算Gr，修改Gr中的边的时候，我们采取这种修改方式：假设我们减少Gr中某条边(v, w)的流量fvw，我们在Gr中又增加一条边(w, v)并且流量也为fvw</li>
<li>修正之后的算法，令人惊讶的是，如果每条边的容量是有理数（rational numbers），算法总是能够保证在获得最大流（maximum flow）的时候停止，证明太难而不在此说明，而且这个算法当图中存在循环（cycle）的时候也可行</li>
<li>如果边的容量都是整数，而且最大流量是f，由于每一条增广路径至少增加1个单位的流量，那么算法最多有f个阶段，因此算法的总共运行时间为O(f*|E|)，因为使用无权中最短路径算法，我们可以在O(|E|)中找到一条增广路径，这个复杂度是有它的缺陷的，因为如果每次都寻找到得增广路径都只增加1个单位的流量（因此要经过很多次），而实际上通过选取其他增广路径，可以很快的得到最大流量值，这种情况下就需要对增广路径进行选择</li>
<li>解决上面的问题的简单方法是选择可以最大增加流量的增广路径，寻找这样的路径跟解决带权重最短路径问题，并且只需要简单地修改狄克斯特拉算法的一行就能解决上面的问题，如果CAPmax是最大的边容量，那么可以证明O(|E|log CAPmax)次增广路径选择就可以获得最大流，在这种情况下，O(|E|log|V|)的时间用来寻找一条流量最大的增广路径，所以总时间则为O(|E|^2 <em> log|V| </em> logCAPmax)，如果容量都是小整数那么复杂度为O(|E|^2 * log|V|)</li>
<li>另一种解决方法是选择拥有最小边数的增广路径，因为这种情况下容量小的边出现的可能更小，使用这个规则O(|E||V|)次增广路径的选择就可以获得最大流，每一步使用无权中最短路径算法需要O(|E|)的时间复杂度，因此整个时间复杂度为O(|E|^2 * |V|)</li>
<li>其它的数据结构还能够更进一步提升算法性能，并且还有一些其它更复杂度算法。一个这个问题的已知的最好的时间复杂度是O(|E|<em>|V|</em>log(|V|^2/|E|))。对于一些特殊情况，也有很好的时间复杂度，例如，如果图中除了源节点和sink节点都只拥有一个容量为1的入边和一条容量为1的出边，那么时间复杂度为O(|E||V|^(1/2))</li>
<li>上面那些算法的分析非常复杂，而且最坏情况也很不明了，另外更复杂的问题是min-cost flow问题，这个问题中，每一条边不仅有容量，而且还有单位流量的开销，问题是要找到所有最大流中，开销最小的那一个</li>
</ul>
</li>
</ul>
</li>
<li>Minimum Spanning Tree<ul>
<li>接下来要考虑的问题是如何在无向图中找到一个最小生成树（minimum spanning tree），对于有向图这个问题也是有意义的，但是会更加困难。非正式的，无向图G中最小生成树是这样的树：树中包含的图的边连接图中所有的节点并且这些边的开销总和最小。最小生成树存在当且仅当图是连通的，尽管一个鲁棒的算法会报告出来图不是连通的情况，但是这里我们假设图都是连通的</li>
<li>最小生成树的边数为|V|-1，最小生成树是树结构应为它是非循环的（无环）。当我们想要用最少的线缆来给房子布线时，我们就需要解决最小生成树问题，我们有两个算法解决最小生成树问题，它们都属于贪婪算法</li>
<li>Prim’s Algorithm<ul>
<li>一种生成最小生成树的方法是一步一步增长树（grow the tree in successive stages），每一步中，一个节点被选作根节点，然后我们添加一条边和它相关联的节点到树中，在算法的任何一步中，我们可能发现一些点已经存在于树中，另外一部分点没有在树种，算法在每一步中选择一条边(u, v)并且该边的开销是所有一个节点在树中，另一个节点不在树中所组成的边中最小的</li>
<li>算法初始时选择一个节点，初始时，最小生成树只有一个根节点，没有其他边和节点。算法的每一步添加一条边和一个节点到最小生成树中</li>
<li>我们可以看到，普林姆算法（Prim’s Algorithm）和狄克斯特拉最短路径算法是一样的，跟前面一样，我们对每个节点记录这样一些信息：<ul>
<li>dv，pv和一个记录节点是否被处理过的布尔值</li>
<li>dv是从某个已经被处理过的（已经被处理过是指已经加入到最小生成树中）节点连接到v节点的最短的那条边的开销，pv是使得dv改变的那条边上v相对的另一个节点（目前连接v节点最短边上v相对的另一个节点，这个节点是已经被处理过的），普林姆算法余下的部分和狄克斯特拉算法是一样的，除了dv的定义是不一样的，所以dv改变的规则也就不一样，对于普林姆算法中dv的定义，dv改变的规则更简单：假如v节点是被处理过的节点，那么对于和v节点相邻的每一个未被处理的w节点，新的dw = min(旧的dw, cwv)</li>
</ul>
</li>
<li>整个普林姆算法的分析也和狄克斯特拉算法的分析是一样的，任何狄克斯特拉算法的分析也使用于普林姆算法，但是要注意普林姆算法用于无向图上，所以邻接表中每条边都要存放两次</li>
<li>不使用优先队列，时间复杂度为O(|V|^2)，对于稠密图效果较好；使用优先队列，复杂度为O(|E|log|V|)，这对于稀疏图效果更好</li>
</ul>
</li>
<li>Kruskal’s Algorithm<ul>
<li>第二个解决最小生成树问题的贪婪算法是克鲁斯卡尔算法（Kruskal’s Algorithm），这个算法的策略是每次选择权重最小的并且不会构成循环（环cycle）的边加到最小生成树中</li>
<li>初始化的时候，图中有|V|个单节点的树，添加一条边，就会将连个单节点树合并成一个树。当算法结束时，只有一颗包含所有节点的树，而且它就是最小生成树</li>
<li>这个算法在当有足够多边时会停止，判断一条边是否加入树是很简单的。上一章将的union/find算法在这里很适用</li>
<li>我们判断两个点属于同一个集合（union/find中的概念）当且仅当它们是否在森林中是相连的（已经在一棵树中），因此初始化的时候，每一个节点都在自己的集合中（集合只包含节点自身）</li>
<li>如果u和v节点在一个集合中，那么它们两就不能合并，因为它们已经相连了，加入边(u, v)可能导致出现循环。否则，我们可以将它们合并，并且我们在分别包含u节点和v节点的集合上执行union操作</li>
<li>按权重大小对边进行排序，这对边的选择是有利的，可以通过在线性时间内建立一个堆来完成，堆的delete_min操作可以按照边权重大小顺序来对边进行测试。尽管建立最小生成树可能需要对所有边进行测试，但是通常情况下，算法结束前只有一小部分边需要测试</li>
<li>最坏情况下的时间复杂度为O(|E|log|E|)，而由于|E| = O(|V|^2)，所以运行时间为O(|E|log|V|)，事实上算法要比这个时间复杂度运行得更快（因为通常只有一小部分边需要测试）</li>
</ul>
</li>
</ul>
</li>
<li>Applications of Depth-First Search<ul>
<li>深度优先搜索是先序遍历的泛化一般化，从某个节点v开始，我们处理v节点然后递归地（以同样的方式即先序遍历）访问所有和v相连的其他节点，如果这个过程是在树上进行的，那么所有树节点都是在总时间O(|E|)内被访问，因为|E|=O(|V|)，如果我们在任意图上执行这个先序遍历，为了防止<strong>循环访问</strong>的出现，当我们访问一个节点v时，我们将其标记为已访问，然后对与其相邻的没有被访问的节点递归地调用深度优先搜索</li>
<li>如果图不是连通的活着强连通的，那么一次深度优先遍历可能访问不到某些节点，但是我们可以对那些没有访问过的节点再使用深度优先遍历</li>
<li>Undirected Graphs<ul>
<li>无向图是连通的当且仅当从图中任意一个节点开始的深度优先搜索可以遍历任意其他节点，因为这个检测非常简单，所以我们假设我们处理的图都是连通的，否则我们通过多次调用深度优先遍历，我们可以找到所有连通分支</li>
<li>通过深度优先遍历，我们可以获得深度优先生成树（depth-first spanning tree），当我们使用优先遍历递归的时候，如果检测某条边(u, w)时，w没有访问过，那么我们就在u和w间添加一条实线边，否则添加一条虚线边（表示这条边不是树的一部分），深度优先生成树是对深度优先遍历的一个模拟</li>
<li>如果图不是连通的，那么需要多次调用深度优先遍历程序来访问图中所有节点，每一次调用都会生成相应地深度优先生成树，这些树组成了深度优先生成森林（depth-first spanning forest）</li>
</ul>
</li>
<li>Biconnectivity<ul>
<li>一个连通无向图叫做biconnected（双连通）的，如果当某个节点移除后不会导致剩下的图变成非连通</li>
<li>假设图是biconnected的，节点表示计算机，边表示连接，那么如果任意一个计算机出故障，网络邮件也不会受影响，除非，邮件就是从出故障的计算机发出或接收；类似的，如果交通运输系统是双连通的，那么如果一些站中断了，我们任然可以找到另一条路径</li>
<li>如果图不是双连通的，那么那个移除后导致图变得非连通的节点就叫做关节节点（articulation points），这些节点在某些应用中非常重要</li>
<li>深度优先搜索算法提供给一个线性复杂度的算法来找到连通图中所有的关节节点<ul>
<li>首先，从任意节点开始，我们对其进行深度优先搜索并且为其标上序号，对于每一个节点我们称这个序号preorder num为num(v)，然后对于深度优先生成树的每一个节点，我们计算lowest-numbered节点，称为low(v)，它表示从v节点经过零条或者多条生长树中的边（或者可能加上一条返回的边———生长树中的虚线）能够到达的含有最小的num的节点的num（太绕了）</li>
<li>我们可以通过对深度优先生长树的后序遍历有效的计算出low，通过low的定义，low(v)的值为如下值中最小的那个：<ul>
<li>num(v)，这个情况发生在生长树中没有从v发出的边（无论是实边还是虚边）</li>
<li>对于边(v, w)，如果是虚边，那么取num(w)</li>
<li>对于边(v, w)，如果是树边，那么去low(w)</li>
<li>上面三个值中最小的那个值就是v的low值</li>
<li>上面三个值分别表示三个不同的递归调用，因为我们在决定low(v)之前需要获得所有v节点的孩子节点的low值，所以这是一个后序遍历，对于一条边(v, w)，我们可以简单的检查num(v)和num(w)来分辨它是否为虚边或者是树边（num(v)&gt;num(w)则为虚边，num(v)&lt;num(w)则为树边）</li>
<li>因此计算low(v)很简单，对一个节点，我们仅需扫描v的邻接表，对访问到的节点使用相同的规则，并且记录最小的值。这些工作需要O(|E|+|V|)的时间复杂度</li>
</ul>
</li>
<li>剩下需要做的就是根据上面的信息寻找到关节节点了，对于深度优先最小生成树，root节点是关节节点当且仅当它有一个以上的孩子节点，因为如果有两个以上的孩子节点，那么删除root就会将两个孩子节点分离到两个不同的子树中去，而如果只有一个孩子节点，那么删除root节点仅仅分离了root节点</li>
<li>对于非root节点v，v是关节节点当且仅当（if and only if）v节点有孩子节点w并且low(w)≥num(v)，需要注意的是这个条件对于根节点是一直成立的，所以这里需要进行特别的检测，对这一条件的证明是：对于if这一部分的证明（充分条件）是由于low(w)≥num(v)，所以从w到比num(v)小的节点只有一种方法，那就是经过v，因此删除v就会使得图被分离成不连通的图，对于only if这一部分的证明（必要条件）实际上是要证明我们通过low(w)≥num(v)这个条件能够找到所有的关节节点（不知道答案，不过我想应该可以用反证法证明吧）</li>
</ul>
</li>
<li>有了上面的分析，对于算法的实现，最简单的一个方法就是，先对图进行一个先序遍历，确定每个节点的num，然后再对图进行后序遍历，确定每个节点的low，最后对图进行一次遍历，确定哪些点是关节节点</li>
<li>但是实际上这三次遍历是很浪费的，在这里先序遍历和后序遍历是可以同时进行的，分别确定每个节点的num和low，同时可以找出关节节点</li>
</ul>
</li>
<li>Euler Circuits<ul>
<li>如下图欧拉回路，我们玩过一笔画游戏，一笔画出一幅图，笔不能离开纸，每条边只能经过一次，这就是欧拉回路，更难的挑战是，最后需要回到出发点，实际上这个游戏有一个非常简单地方法</li>
<li><img src="/img/onedraw.png" alt="一笔画/欧拉回路"></li>
<li>第一幅图只有当从左下角和右下角开始画才可能一笔画完，并且不可能回到出发点，第二幅图很容易一笔画完并且回到出发点，第三幅图不能一笔画完</li>
<li>我们可以把这个问题转换成图理论的问题，上面的一笔画问题的图对应下面的转换后的图，如果我们需要解决“extra challenge”（即一笔画完并且回到出发点），那么我们必须找到一个cycle并且这个cycle对每条边访问一次，这个图问题在1736年被Euler解决了，因此这个问题通常根据问题的程序被叫做Euler path或者Euler circuit问题。欧拉路径和欧拉回路问题虽然有一些不同，但是它们有相同的解决方案。因此我们在这一章考虑欧拉回路问题</li>
<li><img src="/img/onedrawconver.png" alt="一笔画转换后的图"></li>
<li>因为欧拉回路最终要回到初始节点，这只有在图是连通的，并且每一个节点的度（变的数目）为偶数，因为在欧拉回路中，都是先进入一个节点，然后又从那个节点离开，如果一个节点的度为奇数，那么最终我们访问到只剩一条进入v节点的边没有访问，如果我们访问这条边，那么我们就被困在v节点内（这是对非出发点而言，对于出发点，显然要有偶数条边，否则最后回不到出发点）</li>
<li>如果图中有两个奇树度的节点，如果我们从奇数度的节点出发并且回到另一个奇数度的点，那么访问每一条边一次并且不需要回到出发点的欧拉回路有可能存在。如果存在两个以上的奇数度的节点，那么这种欧拉之旅（Euler tour）就不可能</li>
<li>上面的观察告诉我们，存在欧拉回路的必要条件，但是并不是说满足那些条件就一定有欧拉回路（充分条件），也没有告诉我们怎么样寻找到这个回路。事实上，上面的条件也是充分条件，也就是说，如果一个连通图中的每个节点的度都为偶数，那这个图一定存在欧拉回路，此外，我们可以在现行时间内找到这条回路</li>
<li>我们可以假设我们知道图中是否存在欧拉回路，因为我们可以在线性时间内检测上面那个充分必要条件，接下来我们想到的使用深度优先搜索算法，但是用这个算法有一些问题</li>
<li>最主要的问题是，我们可能提前回到了原点而且返回了这个结果，解决办法是在原图除去刚才那条路径上已经访问的边的剩余图上找到刚才这条路径上第一个还有未访问边的节点，然后从这个节点开始再进行深度优先遍历，这可能又会得到一个提前回到这个节点（刚才那个还有未访问边的节点）的路径，我们将这个路径拼接（从上一步还有未访问边的节点开始）到上一个出现循环的路径中，然后接着使用上面的方法，在原图除去新生成的路径上已经访问的边的剩余图上找到这条路径上第一个还有未访问边的节点，然后从这个节点开始进行深度优先遍历，重复上述过程，一直到所有的边都访问过，算法结束得到Eurel circuit</li>
<li>为了让算法高效，我们需要使用合适的数据结构，为了实现简单，路径需要使用链表存储，为了放置邻接表重复访问，我们需要为每一个邻接表添加一个指针，指向最后一条被访问的边，当路径被拼接到原路径中时，我们需要从拼接节点开始寻找下一个执行dfs的节点，这保证了寻找执行dfs的节点的时间复杂度为O(|E|)，算法总共运行时间为O(|E|+|V|)</li>
<li>一个类似的问题是在无向图中找到一个访问所有节点的简单回路（simple cycle），这也叫做哈密顿回路问题，尽管看上去它和欧拉回路问题类似，但是现在并没有找到有效的算法，后面会看到这个问题</li>
</ul>
</li>
<li>Directed Graphs</li>
</ul>
</li>
</ul>

      
    </div>
    
    <footer>
      <div class="alignleft">
      
  
  <div class="categories">
    <a href="/categories/Algorithm/">Algorithm</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/graph/">graph</a>
  </div>

      </div>
      <div class="clearfix"></div>
    </footer>
    
  </div>
</article>


<section id="comment">
  
            <!-- Duoshuo Comment BEGIN -->
            <div class="ds-thread"></div>
            <script type="text/javascript">
                var duoshuoQuery = {short_name:"jjliu"};
                (function() {
                    var ds = document.createElement('script');
                    ds.type = 'text/javascript';ds.async = true;
                    ds.src = 'http://static.duoshuo.com/embed.js';
                    ds.charset = 'UTF-8';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
                })();
            </script>
            <!-- Duoshuo Comment END -->
      
  
</section>

</div></div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer"><div class="inner"><div class="alignleft">
  <p>
  
    &copy; 2014 Jin Liu
  
  </p>
  <p>
   Theme By <a href="http://www.jjliu.tk" >Jin</a>
   based on <a href="http://github.com/willerce/hexo-theme-noderce">Noderce</a>
  </p>

</div>
<div class="clearfix"></div>
</div></footer>
  <script type="text/javascript">

</script>

</body>
</html>
